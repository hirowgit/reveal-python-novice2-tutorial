# L5M1S1

## map()関数

ここでは、map()関数について学びます。

* map()関数は、リストのような複数の値を持つ変数（iterable、イテラブル）に対して、同じ関数をそのすべての値に適用するものです。
* あとで学習するNumpyモジュールでは複数の値に自動的に適用されますが、通常関数は１つの値に適用するように設計されているため、関数の引数（入力）にリストなどを入れるとエラーが出ます。
* そのため、for文のような繰り返し処理で関数を一つずつ適用するか、map()関数を使う必要があります。
* 基本的な使い方：
  * func: 適用したい関数（既存の関数、自作関数、lambda 関数など）
  * iterable: 適用対象のリスト、タプル、ジェネレータなどの反復可能なオブジェクト
  * **使い方：map(func, iterable)**
  * 注意：funcが複数の引数（入力）を必要とする場合は、map(func, iterable1, iterable2)のように書きます。
* 戻り値: map オブジェクト（反復可能なオブジェクトの要素を一つずつ返すオブジェクト、つまりイテレータ）になります。print関数などで表示すると <map object at 0x...> となり、中身がすべて表示されません。
* 中身がすべて表示したい場合は list() や for で展開します。

<1,1>
--

<1,2>

1. map()関数を用いて、整数で定義されたリスト[1,2,3]を、実数のリスト[1.0, 2.0, 3.0]に変換し、ans1に入れます。

```python
#Level 1:
ans1 = ??(float,[1,2,3])
```

```python
ans1 = map(float,[1,2,3])
#print(list(ans1))
#ans1 = [1.0, 2.0, 3.0]
```

--

<1,3>

2. map()関数を用いて、整数で定義されたリスト[3,4,5]が、実数のリスト[3.0, 4.0, 5.0]に変換し、ans2に入れます。

```python
#Level 2:
ans2 = ??(??,[3,4,5])
```

```python
ans2 = map(float,[3,4,5])
#print(list(ans2))
#ans2 = [3.0, 4.0, 5.0]
```

--

<1,4>

3. map()関数を用いて数値のリスト[3,4,5]が、文字列のリスト['3', '4', '5']に変換し、ans3に入れます。

```python
#Level 3:
ans3 = ??(str,[3,4,5])
```

```python
ans3 = map(str,[3,4,5])
#print(list(ans3))
#ans3 = ['3', '4', '5']
```


--

# L5M1S2

## map()関数（発展）

ここでは、map()関数について、さらに学びます。

* 前述の内容に続いて、map()関数について理解します。
* ここではいろいろな既存関数（str, int, ordなど）を使ってみましょう。
* ここで、ord関数は文字に対して、アスキーコード（文字ごと紐付けられた番号）を返すものです。

<1,5>

1. map()関数を用いて、数値が文字列に変換されるように、関数を選んでコード記述を完成させて、ans1に入れます。

```python
#Level 1:
# str(1) => '1'
ans1 = map(??,[1,2,3])
```

```python
ans1 = map(str,[1,2,3])
#print(list(ans1))
#ans1 = ['1', '2', '3']
```

--

<1,6>

2. map()関数を用いて、文字列が数値に変換されるように、関数を選んでコード記述を完成させて、ans2に入れます。

```python
#Level 2:
# int(-1) => '3'
ans2 = map(??,['1','2','3'])
```

```python
ans2 = map(int,['1','2','3'])
#print(list(ans2))
#ans2 = [1, 2, 3]
```

--

<1,7>

3. map()関数を用いて、文字列がアスキーコードに変換される（['a','b','c']⇒[97, 98, 99]）ように、関数を選んでコード記述を完成させて、ans3に入れます。

```python
#Level 3:
# ord('a') => 97
ans3 = map(??,['a','b','c'])
```

```python
ans3 = map(ord,['a','b','c'])
#print(list(ans3))
#ans3 = [97, 98, 99]
```


--

---

# L5M2S1

## lambda 関数の定義

<2,1>
ここでは、無名（アノニマス）関数として、lambda 関数の定義について学びます。

* lambda 関数では、defで定義せずに、簡単に1行だけの関数を作ることができます。
* 一時的に使う関数によく用いられます。数式の定義と近い感覚で扱え、数学的な処理の組み込みにとても有効です。
* 基本的な使い方：**lambda 引数: 式**
  * 式に入れられるのは、算術演算、条件式（三項演算子）、関数呼び出し、メソッドのチェーン（定義済みのlambda関数も式の中に組み込むことができます）、リスト／辞書／集合の作成、内包表記（comprehension）、既存関数との組み合わせ（map, filter, sorted など）になります。
  * return は不要です。式の結果がそのまま返ります。
  * 基本的に1行で定義します。for や while のような繰り返し文はdef関数で使います（map関数と組み合わせて繰り返し処理を組み込む例もあります）。

<2,1>
--

<2,2>

1. 足し算を使って「引数に1を足す」lambda 式を設計し、返り値を ans1 に入れます。

```python
func1 = ?? x: x+1
ans1=func1(2)
#ans1 = 3
```

```python
func1 = lambda x: x+1
```

--

<2,3>

2. 掛け算を使って「引数を2倍する」lambda 式を設計し、返り値を ans2 に入れます。

```python
#Level 2:
func2 = ?? x: x*2
ans2=func2(2)
#ans2 = 4
```

```python
func2 = lambda x: x*2
```

--

<2,4>

3. 引き算を使って「引数から1を引く」lambda 式を設計し、返り値を ans3 に入れます。

```python
#Level 3:
func3 = ?? x: x-1
ans3=func3(2)
#ans3 = 1
```

```python
func3 = lambda x: x-1
```

--
# L4M2S2

## lambda 関数と数式

<2,5>
ここでは、引き続き無名関数、lambda 関数について学びます。

* 前述の内容に加え、数式のような形で、式を定義します。

1. 2+3=5を計算するlambda 式を定義し、その結果をans1 に入れます。

```python
#Level 1:
func1 = ?? x,y: x+y
ans1=func1(2,3)
#ans1 = 5
```

```python
func1 = lambda x,y: x+y
```

--

<2,6>

2. 2×3=6を計算するlambda 式を定義し、その結果をans2 に入れます。

```python
#Level 2:
func2 = ?? x,y: x*y
ans2=func2(2,3)
#ans2 = 6
```

```python
func2 = lambda x,y: x*y
```

--

<2,7>

3. 2-3=-1を計算するlambda 式を定義し、その結果をans3 に入れます。

```python
#Level 3:
func3 = ?? x,y: x-y
ans3=func2(2,3)
#ans3 = -1
```

```python
func3 = lambda x,y: x-y
```

--
---

# L4M3S1

## リスト整形処理の練習（リストの中のリストの長さを数えて、リスト化する）

<3,1>

ではいよいよ、データ整形を始めます。まず、練習として（リストの中に入っている）リストの要素（長さ）を数えて、それに計算を加えることから始めてみましょう。

* リスト内包表記をつかって、Listの中に入っている要素（これもリスト）の要素数を数えて、各個数をリストにすることを考えます。
* つまり、List=[[1,2,3],[1,2],[1],[],...]であれば、結果が[3個, 2個, 1個, 0個,...]と返ってきて欲しいわけです。
* これは、[len(x) for x in List]のように簡単に求めることができます。
* リスト内包表記内でも、計算を加えることができます。例えば、[len(x)+3 for x in List]のよう、各要素数に３を足すなどの計算です。

1. Listの各要素数を数えて、結果が[0,1,2,3,4]になるように、リスト内包表記を設計し、適切な記述を ans1 に入れます。

```python
#Level 1:
List = [[],[1],[1,2],[1,2,3],[1,2,3,4]]
ans1 = [? for x in List]
```

```python
ans1 = [len(x) for x in List]
```

--

<3,2>

2. Listの各要素数に対して、毎回１を足して、結果が[1,2,3,4,5]になるように、リスト内包表記を設計し、適切な記述を ans2 に入れます。

```python
#Level 2:
List = [[],[1],[1,2],[1,2,3],[1,2,3,4]]
ans2 = [? + len(x) for x in List]
```

```python
ans2 = [1 + len(x) for x in List]
```

--

<3,3>

3. Listの各要素数に対して、毎回２を足して、結果が[2,3,4,5,6]になるように、リスト内包表記を設計し、適切な記述を ans2 に入れます。

```python
#Level 3:
List = [[],[1],[1,2],[1,2,3],[1,2,3,4]]
ans3 = [? + len(x) for x in List]
```

```python
ans3 = [2 + len(x) for x in List]
```

--
# L4M3S2

## リスト整形処理

<3,4>

では、リストの要素を整えるリスト整形処理に入ります。これを理解すると、リストの加工・変換・並び替えなどの操作ができるようになります。リスト内包表記の中にif文を加える方法も学びます。

* 前述の解説で、リスト内包表記を用いるとてリストの数は、List = [ [ ], [5], [2, 3], [1, 6], [1, 6, 9]]のときに、[0,1,2,2,3]のように要素の数が求められることがわかりました。
* 全部を長さ４に揃えたい時は、足りない分、[4-0,4-1,4-2,4-2,4-3]=[4,3,2,2,1]の[0]を準備して、元のリストに結合（+）することで、すべて同じ長さのリストが得られます。
* ここで、0を追加する必要がないケースを考えます。リストxの要素数が４（len(x)==4）のときは、xに[0]*0を加えず、そのままのxを使い、それ以外のときに[0,0,0,...]のリストとxを連結する方法です。
* そのときは、リスト内包表記にx if len(x)==4 else x+[0]*(4-len(x)) と書くことができます。
* **復習：**リスト（数列）が3個あるか、それよりも少ないかを判断　len(x) == 3
* **復習：**足りない0を数える（3から、数列の長さ(len)を引く）　3 - len(x)
* **復習：**足りない分の0を、数列（リスト）にする　[0] * (3 - len(x))
* **復習：**足りない分の0を、元の数列に連結する　x + [0] * (3 - len(x))

--
<3,5>

1. ans1 が[[0,0,0,0], [1,0,0,0], [1,2,0,0], [1,2,3,0], [1,2,3,4]]になるように、リスト内包表記の?を考えて修正し、結果を ans1 に入力します。

```python
#Level 1:
List = [[],[1],[1,2],[1,2,3],[1,2,3,4]]
ans1 = [ x+[0]*(?-len(x)) for x in List ]
```

```python
ans1 = [ x+[0]*(4-len(x)) for x in List ]
```

--

<3,6>

2. ans2 が[[0,0,0,0], [1,0,0,0], [1,2,0,0], [1,2,3,0], [1,2,3,4]]になるように、リスト内包表記の?を考えて修正し、結果を ans2に入力します。

```python
#Level 2:
List = [[],[1],[1,2],[1,2,3],[1,2,3,4]]
ans2 = [x if len(x)==4 else x+[0]*(?-len(x)) for x in List ]
```

```python
ans2 = [x if len(x)==4 else x+[0]*(4-len(x)) for x in List ]
```

--

<3,7>

3. ans3 が[[0,0,0,0,0], [1,0,0,0,0], [1,2,0,0,0], [1,2,3,0,0], [1,2,3,4,0]]（要素が５であることに注意）になるように、リスト内包表記の?を考えて修正し、結果を ans3 に入力します。

```python
#Level 3:
List = [[],[1],[1,2],[1,2,3],[1,2,3,4]]
ans3 = [x if len(x)==? else x+[0]*(?-len(x)) for x in List ]
```

```python
ans3 = [x if len(x)==5 else x+[0]*(5-len(x)) for x in List ]
```

--

---

# L4M4S1

## 辞書型の取り扱い

<4,1>

ここでは、辞書型の取り扱いを学びます。

* 辞書は、キーと値の２種類のデータを対（セット）にすることで、キーを用いて値を簡単に呼び出すことができます。
* リストから検索する必要がないため、高速に必要な値を取り出すことができます。
* キー(key)と値(value)の間は、「:」（コロン） で区切り、辞書型（dictionary） のデータを定義できます。
* キーと値のセットは、「,」で区切って並べることで、複数のデータをひとまとめにして扱うことができます。
* キーは、数字、文字または文字列でも問題ありません。但し、同じキーは1回だけ用い、対応する値は、ひとかたまり、つまりひとつの要素（リストで良い）にしておく必要があります。
* 辞書（ディクショナリ）型は、全体を{}で囲みます（リスト型では、左右の端を**[]の記号**で囲むことを学びました）。

--

<4,2>

1. "Name", "Steve"の文字を、辞書型としてまとめ、ans1に入れます。

```python
#Level 1:
ans1 = ?"Name" : "Steve"?
```

```python
ans1 = {"Name" : "Steve"}
```

--

<4,3>

2. キーの"Age"と値の29が、辞書型としてまとめ、ans2に入れます。

```python
#Level 2:
ans2 = {"Age" ? 29}
```

```python
ans2 = {"Age" : 29}
```

--

<4,4>

3. 二つの要素を、辞書型としてまとめ、ans3に入れます。

```python
#Level 3:
ans3 = {"Name" : "Steve" ? "Age" : 29}
```

```python
ans3 = {"Name" : "Steve" , "Age" : 29}
```

--

# L4M4S2

## 辞書型の取り扱い（キー）

<4,5>

ここでは、辞書型の取り扱い（キー）を学びます。

* keys() メソッドを用いて、辞書（dictionary）のすべてのキー（key）を集めたオブジェクトを返すことができます。
* 返されるのは dict_keys オブジェクトです。リスト型と同一ではないですが、for文による繰り返し処理には利用できます（イテラブル）。リスト型に変換したい場合はlist(D)のように、Dに結果として得られたdict_keys オブジェクトを入れ、必要に応じて変換できます。

1. .keys()メソッドを用いて{"Name" : "Steve"}のすべてのキーをans1に入れます。

```python
#Level 1:
dict1 = {"Name" : "Steve"}
ans1=dict1.??()
```

```python
ans1=dict1.keys()
```

--

<4,6>

2. .keys()メソッドを用いて{"Age" : 29}のすべてのキーをans2に入れます。

```python
#Level 2:
dict2 = {"Age" : 29}
ans2=dict2.??()
```

```python
ans2=dict2.keys()
```

--

<4,7>

3. .keys()メソッドを用いて{"Height" : 180, "Weight" : 80}のすべてのキーをans3に入れます。

```python
#Level 3:
dict3 = {"Height" : 180, "Weight" : 80}
ans3=dict3.??()
```

```python
ans3=dict3.keys()
```

--

# L4M4S3

## 辞書型の取り扱い（値）

<4,8>

ここでは、辞書型の取り扱い（値）を学びます。

* values() メソッドを用いて、辞書（dictionary）のすべての値（value）を集めたオブジェクトを返すことができます。
* 返されるのはdict_values オブジェクトです。リスト型と同一ではないですが、for文による繰り返し処理には利用できます（イテラブル）。リスト型に変換したい場合はlist(D)のように、Dに結果として得られたdict_keys オブジェクトを入れます。したがって、必要に応じてfor文などの繰り返し処理で使うことができます。
* dict1[キー]=値、の形でキーに紐づいている値を更新できます。この場合、元の値は上書き（消去）されることに注意してください。もし値を上書きするのでなく、追加したい場合は、値をリスト型にして、.appendメソッドで追加するなどの、別の計算が必要です。

1. .valuse()メソッドを用いて{"Name" : "Steve"}の全ての値をans1に入れます。

```python
#Level 1:
dict1 = {"Name" : "Steve"}
ans1=dict1.??()
```

```python
ans1=dict1.values()
```

--

<4,9>

2. .valuse()メソッドを用いて{"Age" : 29}の全ての値をans2に入れます。

```python
#Level 2:
dict2 = {"Age" : 29}
ans2=dict2.??()
```

```python
ans2=dict2.values()
```

--

<4,10>

3. .valuse()メソッドを用いて{"Height" : 180, "Weight" : 80}の全ての値をans3に入れます。

```python
#Level 3:
dict3 = {"Height" : 180, "Weight" : 80}
ans3=dict3.??()
```

```python
ans3=dict3.values()
```

--

# L4M4S4

## 辞書型の取り扱い（キーと値のセット）

<4,8>
ここでは、辞書型の取り扱い（反復処理）を学びます。

* items() メソッドを用いて、辞書（dictionary）のすべてのキー（key）と値（value）の組をタプル [L3M4S2](https://hirowgit.github.io/reveal-python-novice2-tutorial/lecture3.html#/3/4)として返すことができます。
* 返されるのは dict_values オブジェクト で、これもイテラブルでfor文などに使えます。後で解説するzip関数をつかって、繰り返し処理内でキーと値を同時に取り出すことができます。


1. .items()メソッドを用いてキーと値の組("Name", "Steve"), ("Age", 29), ("Height", 180), ("Weight", 80), ("hobby", "baseball")を取り出し、ans1に入れます。

```python
#Level 1:
dict1 = {"Name" : "Steve", "Age" : 29, "Height" : 180, "Weight" : 80, "hobby" : "baseball"}
ans1=dict1.??()
```

```python
ans1=dict1.items()
```

--

<4,9>

2. .items()メソッドを用いてキーと値の組("Name", "Steve"), ("Age", 29), ("Height", 180), ("Weight", 80), ("hobby", "baseball")を取り出し、リスト内包表記で各組をリスト型にしてans2に入れます。

```python
#Level 2:
dict2 = {"Name" : "Steve", "Age" : 29, "Height" : 180, "Weight" : 80, "hobby" : "baseball"}
ans2=[x for x in dict2.??()]
```

```python
ans2=[x for x in dict2.items()]
```

--

<4,10>

3. dict3が[("Name", "Steve"), ("Age", 29), ("Height", 180), ("Weight", 80), ("hobby", "baseball")]になるように、.items()メソッドを用いたfor文で、上のリスト内包表記と同じになるように適切に記述します。

```python
#Level 3:
dict3 = {"Name" : "Steve", "Age" : 29, "Height" : 180, "Weight" : 80, "hobby" : "baseball"}
ans3 = []
for x in dict3.??():
    ans3 = ans3 + [x]
ans3
```

```python
for x in dict3.items():
    ans3 = ans3 + [x]
```

--
---

# L4M5S1

## 集合型の取り扱い（定義）


<5,1>

ここでは、集合型の取り扱いを学びます。

* 集合型には、数学の「集合」とほぼ同じ概念で扱えます。
* 集合型の定義は、要素を{}で囲みます。または、set() は 集合（set）型を作る関数を使って、()の中にリストを入れて集合型に変換します。
* ディクショナリ型のキーと同様、重複した値を入れても一つの値だけが保存されます。（重複を許すリスト型を集合型に変換すると重複を取り除いてくれます）
* 順序を持たないデータ型なので、要素番号による呼び出しなどはできませんが、要素を追加したり削除したりすることはできます。
* 和集合、積集合、差集合などの様々な集合演算ができ、その演算は"|"、"&"、"-" 演算子またはメソッドを使って行うことができます。

--

<5,2>

1. 1,1,2,3,4,4の数字を、集合型としてまとめて、ans1に入れます。

```python
#Level 1:
ans1 = ?1,1,2,3,4,4?
```

```python
ans1 = {1,1,2,3,4,4}
```

--

<5,3>

2. リスト型[1,1,2,3,4,4]の数字列を、set()関数を用いて集合型へ変換し、ans2に入れます。

```python
#Level 2:
ans2 = ??([1,1,2,3,4,4])
```

```python
ans2 = set([1,1,2,3,4,4])
```

--

<5,4>

3. リスト型[4,4,3,2,1,1]の数字列を、set()関数を用いて集合型へ変換し、ans3に入れます。

```python
#Level 3:
ans3 = ??([4,4,3,2,1,1])
```

```python
ans3 = set([4,4,3,2,1,1])
```


--
<5,5>

# L3M5S2

## 集合型の取り扱い（差集合）

ここでは、集合型の取り扱い（差集合）を学びます。

* 差集合（difference）は、2つの集合 A と B に対して、A には含まれているが、B には含まれていない要素を集めた集合です。
* 数学的には A - B と書き、「A から B を引いたもの」という意味になります。
  *「A と B を比べたときに A にしか存在しない要素」が残ります。
* difference() メソッドは、**集合 A に含まれていて集合 B には含まれていない要素（差集合）**を返します。
* 演算子 - と同じ働きをします。

1. 四則演算（− 引き算）を用いて、2つの集合の差集合を計算し、ans1 に入力します。

```python
#Level 1:
ans1 = {1,2,3,4,5,6,7,8,9} ? {5,6,7,8,9}
```

```python
ans1 = {1,2,3,4,5,6,7,8,9} - {5,6,7,8,9}
```

--

<5,6>

2. .difference() メソッドを用いて、差集型を計算し、ans2に入れます。

```python
#Level 2:
ans2 = {1,2,3,4,5,6,7,8,9}.??({5,6,7,8,9})
```

```python
ans2 = {1,2,3,4,5,6,7,8,9}.difference({5,6,7,8,9})
```

--

<5,7>

3. .difference() メソッドを用いて、差集型を計算し、ans3に入れます。

```python
#Level 3:
ans3 = {1,2,3,4,5,6,7,8,9}.??({9,8,7,6,5})
```

```python
ans3 = {1,2,3,4,5,6,7,8,9}.difference({9,8,7,6,5})
```


--
<5,8>

# L3M5S3

## 集合型の取り扱い（和集合）

ここでは、集合型の取り扱い（和集合）を学びます。

* 和集合（union）は、2つ以上の集合に含まれるすべての要素を集めた集合です。
* A数学的には A ∪ B と書き、A または B に含まれる要素をすべてまとめます。
* 重複は自動的に取り除かれます。
* .union() メソッドとは、複数の集合やイテラブル（リスト・タプルなど）を指定すると、重複を取り除いたすべての要素をまとめた新しい集合を返します。
* 演算子 " | " と同じ働きをします。

1. 演算子 " | " を用いて、2つの集合の和集合としてまとめ、ans1 に入力します。

```python
#Level 1:
ans1 = {1,2} ? {3,4}
```

```python
ans1 = {1,2} | {3,4}
```

--

<5,9>

2. .union() メソッドを用いて、和集合としてまとめ、ans2に入れます。

```python
#Level 2:
ans2 = {1,2}.union({3,4})
```

```python
ans2 = {1,2,3,4,5,6,7,8,9}.difference({5,6,7,8,9})
```

--

<5,10>

3. .union() メソッドを用いて、和集合としてまとめ、ans3に入れます。

```python
#Level 3:
ans3 = {2,1}.?({4,3})
```

```python
ans3 = {2,1}.union({4,3})
```


--

<5,11>

# L3M5S4

## 集合型の取り扱い（積集合）

ここでは、集合型の取り扱い（積集合）を学びます。

* 積集合（intersection）は、2つの集合 A と B に 共通して含まれる要素だけを集めた集合 のことです。
* 数学でいう A ∩ B に対応します。
* 重複は自動的に取り除かれます。
* .intersection() とは、複数の集合に共通して含まれる要素」だけを取り出します。
* 演算子 " & " と同じ働きをします。
* 演算子 " | " と同じ働きをします。

1. 演算子 " & " を用いて、2つの集合の積集合を取り出し、ans1 に入力します。

```python
#Level 1:
ans1 = {1,2,3,4,5,6,7,8,9} ? {1,2,3,4}
```

```python
ans1 = {1,2,3,4,5,6,7,8,9} & {1,2,3,4}
```

--

<5,12>

2. .intersection() メソッドを用いて、積集合を取り出し、ans2に入れます。

```python
#Level 2:
ans2 = {1,2,3,4,5,6,7,8,9}.?({0,1,2,3,4})
```

```python
ans2 = {1,2,3,4,5,6,7,8,9}.intersection({0,1,2,3,4})
```

--

<5,13>

3. .intersection() メソッドを用いて、積集合を取り出し、ans3に入れます。

```python
#Level 3:
ans3 = {1,2,3,4,5,6,7,8,9}.?({4,3,2,1,0})
```

```python
ans3 = {1,2,3,4,5,6,7,8,9}.intersection({4,3,2,1,0})
```


--

